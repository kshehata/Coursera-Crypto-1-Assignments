#include "block_cipher.h"

#include <gtest/gtest.h>
#include <utility>

using std::pair;
using std::make_pair;
using std::make_unique;
using std::tuple;
using std::unique_ptr;
using ::testing::get;
using ::testing::TestWithParam;
using ::testing::Values;

namespace block_cipher {

namespace testing {


class CheckRemovePadTest : 
    public TestWithParam<tuple<bool, string, string>> {

 protected:
  ~CheckRemovePadTest() override {}
  void SetUp() override {}
  void TearDown() override {}
};

TEST_P(CheckRemovePadTest, Examples) {
  const auto exp_success = get<0>(GetParam());
  auto in = get<1>(GetParam());
  const auto& exp = get<2>(GetParam());
  bool result = CBC::check_and_remove_pad(in);
  EXPECT_EQ(result, exp_success);
  if (exp_success) {
    EXPECT_EQ(in, exp);
  }
}

INSTANTIATE_TEST_SUITE_P(CheckRemovePadTestExamples,
                         CheckRemovePadTest,
                         Values(
                          make_tuple(true, string{}, string{}),
                          make_tuple(true,
                            string{
                              0x7A, 0x55, 0x7A, 0x55, 0x7A, 0x55, 0x7A, 0x01},
                            string{
                              0x7A, 0x55, 0x7A, 0x55, 0x7A, 0x55, 0x7A}),
                          make_tuple(true,
                            string{
                              0x7A, 0x55, 0x7A, 0x55, 0x7A, 0x55, 0x7A, 0x55,
                              0x7A, 0x55, 0x7A, 0x55, 0x04, 0x04, 0x04, 0x04},
                            string{
                              0x7A, 0x55, 0x7A, 0x55, 0x7A, 0x55, 0x7A, 0x55,
                              0x7A, 0x55, 0x7A, 0x55}),
                          make_tuple(false, string{0x04, 0x04},
                            string{}),
                          make_tuple(false, string{
                            0x7A, 0x55, 0x7A, 0x55, 0x04, 0x04, 0x05, 0x04},
                            string{}),
                          make_tuple(false, string{
                            0x7A, 0x55, 0x7A, 0x55, 0x03, 0x04, 0x04, 0x04},
                            string{})
                          ));


class AddPadTest :
    public TestWithParam<pair<byte_array, byte_array>> {

 protected:
  ~AddPadTest() override {}
  void SetUp() override {}
  void TearDown() override {}
};

TEST_P(AddPadTest, Examples) {
  auto in = GetParam().first;
  const auto len = in.size();
  in.resize(BLOCK_SIZE);
  const auto& exp = GetParam().second;
  CBC::add_pad(in.data(), len);
  EXPECT_EQ(in, exp);
}

INSTANTIATE_TEST_SUITE_P(AddPadTestExamples,
                         AddPadTest,
                         Values(
                          make_pair(byte_array{
                              0x7A, 0x55, 0x7A, 0x55, 0x7A, 0x55, 0x7A, 0x55,
                              0x7A, 0x55, 0x7A, 0x55, 0x7A, 0x55, 0x7A},
                            byte_array{
                              0x7A, 0x55, 0x7A, 0x55, 0x7A, 0x55, 0x7A, 0x55,
                              0x7A, 0x55, 0x7A, 0x55, 0x7A, 0x55, 0x7A, 0x01}),
                          make_pair(byte_array{
                              0x7A, 0x55, 0x7A, 0x55, 0x7A, 0x55, 0x7A, 0x55,
                              0x7A, 0x55, 0x7A, 0x55},
                            byte_array{
                              0x7A, 0x55, 0x7A, 0x55, 0x7A, 0x55, 0x7A, 0x55,
                              0x7A, 0x55, 0x7A, 0x55, 0x04, 0x04, 0x04, 0x04}),
                          make_pair(byte_array{},
                            byte_array{
                              0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
                              0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10})
                          ));

TEST(DecryptCBCTest, Decrypt) {
  const byte_array key = {
    0x14, 0x0b, 0x41, 0xb2, 0x2a, 0x29, 0xbe, 0xb4,
    0x06, 0x1b, 0xda, 0x66, 0xb6, 0x74, 0x7e, 0x14};

  const byte_array ct = {
    0x4c, 0xa0, 0x0f, 0xf4, 0xc8, 0x98, 0xd6, 0x1e,
    0x1e, 0xdb, 0xf1, 0x80, 0x06, 0x18, 0xfb, 0x28,
    0x28, 0xa2, 0x26, 0xd1, 0x60, 0xda, 0xd0, 0x78,
    0x83, 0xd0, 0x4e, 0x00, 0x8a, 0x78, 0x97, 0xee,
    0x2e, 0x4b, 0x74, 0x65, 0xd5, 0x29, 0x0d, 0x0c,
    0x0e, 0x6c, 0x68, 0x22, 0x23, 0x6e, 0x1d, 0xaa,
    0xfb, 0x94, 0xff, 0xe0, 0xc5, 0xda, 0x05, 0xd9,
    0x47, 0x6b, 0xe0, 0x28, 0xad, 0x7c, 0x1d, 0x81
  };
  const string exp = "Basic CBC mode encryption needs padding.";

  CBC cipher;
  cipher.set_key(key);
  const auto result = cipher.decrypt(ct);

  EXPECT_EQ(exp, result);
}


TEST(EncryptCBCTest, Encrypt) {
  const byte_array key = {
    0x14, 0x0b, 0x41, 0xb2, 0x2a, 0x29, 0xbe, 0xb4,
    0x06, 0x1b, 0xda, 0x66, 0xb6, 0x74, 0x7e, 0x14};

  const string m = "Basic CBC mode encryption needs padding.";

  const byte_array exp_ct = {
    0x4c, 0xa0, 0x0f, 0xf4, 0xc8, 0x98, 0xd6, 0x1e,
    0x1e, 0xdb, 0xf1, 0x80, 0x06, 0x18, 0xfb, 0x28,
    0x28, 0xa2, 0x26, 0xd1, 0x60, 0xda, 0xd0, 0x78,
    0x83, 0xd0, 0x4e, 0x00, 0x8a, 0x78, 0x97, 0xee,
    0x2e, 0x4b, 0x74, 0x65, 0xd5, 0x29, 0x0d, 0x0c,
    0x0e, 0x6c, 0x68, 0x22, 0x23, 0x6e, 0x1d, 0xaa,
    0xfb, 0x94, 0xff, 0xe0, 0xc5, 0xda, 0x05, 0xd9,
    0x47, 0x6b, 0xe0, 0x28, 0xad, 0x7c, 0x1d, 0x81
  };
  CBC cipher;
  cipher.set_key(key);
  const auto result = cipher.encrypt(m, exp_ct.data());

  EXPECT_EQ(exp_ct, result);
}


TEST(DecryptCTRTest, Decrypt) {
  const byte_array key = {
    0x36, 0xf1, 0x83, 0x57, 0xbe, 0x4d, 0xbd, 0x77,
    0xf0, 0x50, 0x51, 0x5c, 0x73, 0xfc, 0xf9, 0xf2};

  byte_array ct = {
    0x69, 0xdd, 0xa8, 0x45, 0x5c, 0x7d, 0xd4, 0x25,
    0x4b, 0xf3, 0x53, 0xb7, 0x73, 0x30, 0x4e, 0xec,
    0x0e, 0xc7, 0x70, 0x23, 0x30, 0x09, 0x8c, 0xe7,
    0xf7, 0x52, 0x0d, 0x1c, 0xbb, 0xb2, 0x0f, 0xc3,
    0x88, 0xd1, 0xb0, 0xad, 0xb5, 0x05, 0x4d, 0xbd,
    0x73, 0x70, 0x84, 0x9d, 0xbf, 0x0b, 0x88, 0xd3,
    0x93, 0xf2, 0x52, 0xe7, 0x64, 0xf1, 0xf5, 0xf7,
    0xad, 0x97, 0xef, 0x79, 0xd5, 0x9c, 0xe2, 0x9f,
    0x5f, 0x51, 0xee, 0xca, 0x32, 0xea, 0xbe, 0xdd,
    0x9a, 0xfa, 0x93, 0x29
  };
  const string exp =
    "CTR mode lets you build a stream cipher from a block cipher.";


  CTR cipher;
  cipher.set_key(key);
  const auto result = cipher.decrypt(ct);

  EXPECT_EQ(exp, result);
}


TEST(EncryptCTRTest, Encrypt) {
  const byte_array key = {
    0x36, 0xf1, 0x83, 0x57, 0xbe, 0x4d, 0xbd, 0x77,
    0xf0, 0x50, 0x51, 0x5c, 0x73, 0xfc, 0xf9, 0xf2};

  const string m =
    "CTR mode lets you build a stream cipher from a block cipher.";

  const byte_array exp_ct = {
    0x69, 0xdd, 0xa8, 0x45, 0x5c, 0x7d, 0xd4, 0x25,
    0x4b, 0xf3, 0x53, 0xb7, 0x73, 0x30, 0x4e, 0xec,
    0x0e, 0xc7, 0x70, 0x23, 0x30, 0x09, 0x8c, 0xe7,
    0xf7, 0x52, 0x0d, 0x1c, 0xbb, 0xb2, 0x0f, 0xc3,
    0x88, 0xd1, 0xb0, 0xad, 0xb5, 0x05, 0x4d, 0xbd,
    0x73, 0x70, 0x84, 0x9d, 0xbf, 0x0b, 0x88, 0xd3,
    0x93, 0xf2, 0x52, 0xe7, 0x64, 0xf1, 0xf5, 0xf7,
    0xad, 0x97, 0xef, 0x79, 0xd5, 0x9c, 0xe2, 0x9f,
    0x5f, 0x51, 0xee, 0xca, 0x32, 0xea, 0xbe, 0xdd,
    0x9a, 0xfa, 0x93, 0x29
  };

  CTR cipher;
  cipher.set_key(key);
  const auto result = cipher.encrypt(m, exp_ct.data());

  EXPECT_EQ(exp_ct, result);
}

TEST(EncryptCBCTest, EncryptDecrypt) {
  const byte_array key = {
    0x14, 0x0b, 0x41, 0xb2, 0x2a, 0x29, 0xbe, 0xb4,
    0x06, 0x1b, 0xda, 0x66, 0xb6, 0x74, 0x7e, 0x14};

  const string m = "This is just some random string, really. Really Random.";

  unique_ptr<BlockCipher> cipher = make_unique<CBC>();
  cipher->set_key(key);
  const auto ct = cipher->encrypt(m);
  const auto result = cipher->decrypt(ct);

  EXPECT_EQ(m, result);
}

TEST(EncryptCTRTest, EncryptDecrypt) {
  const byte_array key = {
    0x14, 0x0b, 0x41, 0xb2, 0x2a, 0x29, 0xbe, 0xb4,
    0x06, 0x1b, 0xda, 0x66, 0xb6, 0x74, 0x7e, 0x14};

  const string m = "This is just some random string, really. Really Random.";

  unique_ptr<BlockCipher> cipher = make_unique<CTR>();
  cipher->set_key(key);
  const auto ct = cipher->encrypt(m);
  const auto result = cipher->decrypt(ct);

  EXPECT_EQ(m, result);
}

} // namespace testing

} // namespace block_cipher
